---
date: 2013-04-10 13:59:21+00:00
layout: post
title: 关于C语言中struct和union的大小
categories: blog
tags:
- alignment
- C++
- struct
- union
description: C语言中有两个比较特别的数据类型，结构体（struct）和联合体（union）
---

C语言中有两个比较特别的数据类型，结构体（struct）和联合体（union）。他们可以由基本数据类型根据一定的组成规则构成。但是，这两个数据类型的大小并不像其他基本类型一样是固定的，它根据所包含的成员的类型大小决定。


##### 结构体（Struct）


首先，说一下结构体的大小问题。

下面的结构体

	struct node{
		int a;
		int b;
	};

可以很明显的看出，这个结构体的大小为8B，因为int的大小为4B，这里两个int成员，所以是8B。

再看另外一个结构体

	struct node{
		char a;
		int b;
	};

这个结构体如果还是按照之前的方法计算的话，应该是5B，其中char是1B，int是4B。但是实际上，**这个结构体的大小是8B**。


插一下，这里查看结构体大小的方法很简单，调用sizeof函数就可以获得，比如



	sizeof(*(struct some_struct*)0)


这样不用定义一个结构体，仅仅把0指针转换成想要的结构体指针就可以了


这个问题引入了一个概念，叫做“内存对齐”。所谓的内存对齐，是指一种计算机体系结构（如X86）对基本数据类型的存储位置有限制，要求其地址为某个数的倍数，通常这个数为4或8。这种要求会简化处理器的设计以及提升数据访问的效率。至于为什么会有这样的设计，简单的说访存总线的位数固定，以32位总线为例，地址总线的地址总是4对齐的，所以数据也四对齐的话，一个周期内就可以把数据读出。

在这个前提下，**编译器会为了效率在成员变量之间进行一些填充来保证数据在内存中是对齐的**。因为X86是4对齐的，所以上面那个结构体的大小是8B而不是5B，因为char后面会被填充3B以用来和int对齐。

下面还有一个结构体

	struct node{
		int a;
		char b;
		char c;
		int d;
		char d;
	};

这个结构体的大小是16B，因为以4B对齐，b和c是要放在一起并且在后面填充2B，而最后的d要在其后填充3B。注意，**结构体里面的定义顺序在编译的时候是不能打乱的**。

要想修改编译器的对齐数也是可以的，在C语言中，可以通过

	#pragma pack(n)

来修改对齐的模数，当然这样的话，最后可能会对生成的程序的效率会有影响。

最后再来看一个例子

	struct node {
		double a;
		int b;
		int c;
		char d;
	};

这个结构体的大小是20B，但是在win环境下的VC中这个结构体的大小是24B。

**这是因为在VC中规定， 结构体变量的首地址能够被其最宽基本类型成员的大小所整除；而在gcc中规定对齐模数最大只能是4，也就是说，即使结构体中有double类型，对齐模数还是4，所以数据是按照1，2，4对齐的。**所以，在两个不同编译器上，得到的结果是不同的。这也正说明了，编译器不同，对齐的方式也不同。


##### 联合体（Union）


首先呐，不要把结构体和联合体当作是类似的，其实两者差别还是比较大的。联合体其实说来应该算是一种自定义的数据类型，只不过它的大小是由包含在内的各个成员的数据类型的大小决定的。

看一个例子

	union u {
		int t;
		short s[7];
	};

这个联合体的大小是多少呢？肯定不可能是4B..但是是14B么？也不是，其实是16B，这里要注意的是虽然变量s数组的大小是14B，但是在这个union中的最大对齐应该是int型，即4B，所以为了对齐，联合体的大小就是16B，而且这个联合体的对齐也就成了4B。

这里的一个主要的概念就是对齐，**一个联合体的对齐取决于它所包含的成员的数据类型，其中数据类型最大的那个即为这个联合体的对齐，当然这里说的类型都是基本类型**。但是由上面我们知道gcc只支持最大4B的对齐，所以即便联合体中有8B的基本类型，它的对齐也不可能是8B了。
