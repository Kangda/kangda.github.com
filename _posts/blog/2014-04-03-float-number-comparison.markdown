---
layout: post
title: 浮点数比较
categories: blog
tags:
- float number
- computer architecture
description: 浮点数在比较的时候不像整数那样直接，涉及到的方面还是挺有意思的。
---

浮点数在计算机里的表示一向和整数不太一样，在运算的时候也有了专门的寄存器来处理，而且对于计算机这种多是离散的结构，在处理浮点数这种连续值的时候确实得多多考虑。

##浮点数的表示

浮点数在计算机存储中不像整数那样直接，两者最大的区别就在于一个有小数位，一个没有。而在浮点数的表示上，计算机中的二进制还是借鉴了十进制的科学表示法。在十进制里，表示一个数字，可以这样：

> $$a * 10^n$$

在二进制的世界，我们也可以这样，照着它的形式来就可以了：

> $$M * 2^E$$

两者可以完全类比。这里要表示的有两个量：M和E。加上之前说的符号位，所以在计算机里表示一个浮点数一共需要三个量：S，M，E。

[IEEE floating-point standard](http://en.wikipedia.org/wiki/IEEE_floating_point)中把一个浮点数表示为

> $$V = (-1)^S * M * 2^E$$

对于32bit的空间，三者的分配是：1bit， 8bit， 23bit；对于64bit的空间，则是：1bit， 11bit， 52bit。

在这种表示方式下，根据E的值，可以分成三种情况：

![cases of float](http://kang-da.tk/images/post/cases-of-float.png)

设E的二进制位表示为$$e = e_{k-1}...e_{1}e_{0}$$，M的二进制位表示为$$f = f_{n-1}...f_{1}f{0}$$。在计算f的值的时候，f中各个位的权值是从1/2开始以1/2为公比的等比数列。

1. Normalized Value
	
	- 在这个case下，e不等于0或者255，f可以为任意值；
	- $$E = e - Bias$$，其中$$Bias = 2^{k-1} - 1$$；
	- 当$$0 \leq f  < 1$$，相当于$$M = 0.f_{n-1}...f_{1}f_{0}$$；其他情况f都是大于1的，所以，最高位的1自动默认，就不再占位了，相当于$$M = 1.f_{n-1}...f_{1}f_{0}$$

2. Denormalized Values

	这个case存在的意义有两个：一，为了表示0；二，为了表示0附近的小数。

	- E所有位都为0，f可以为任意值；
	- $$E = 1 - Bias$$，不是0 - Bias是为了和Normalized Value做平滑过渡；
	- Normalized Value无法表示0，这里可以表示，当E和M的各个位都为0，但是符号的不同会产生-0.0和+0.0，两者在某些情况下被认为是不同的。

3. Special Value

	- E的所有位都为1；
	- M的所有位都是0，当s=0，表示$$+\infty$$，当s=1，表示$$-\infty$$；
	- M不等于0，被称为NaN，即“Not a Number”。

###取整

浮点数由于计算机的表示的局限所以不可能精确的表示出来，所以在对浮点数取值的时候都是要Rounding的，即把浮点数的值用一个它附近的可以用计算机表示出的浮点数来体现。

取值的方式有很多，常见的就是四舍五入，但是四舍五入会造成在统计的角度上整个数的集合偏大，因为五入的数字包括了5,6,7,8,9，而四舍的数字只包括了1,2,3,4，从整体上看这些数字出现的频率相当的时候，五入的次数会多，所以整个集合会变得比原集合更大。在进行取值的时候要避免这点，尽可能前后一致。

round-to-even是[IEEE745](http://en.wikipedia.org/wiki/IEEE_floating_point)中的默认取整模式。在这种模式下，在对一个数取整的时候，要尽可能选择最靠近的数，如果出现有两个最接近的数，即这个数是那两个数的中位数，则选择是偶数的那个（这个偶数的定义不仅限于十进制下的整数，可以扩展到小数部分，同样可以类比到二进制下）。

在二进制下，可以用这样的形式在定义上面说的有两个最接近的数的情况，当一个数的形式的这样的（X和Y之间的是小数点）

> XX...XX.YY...YY100...

其中的XY都可以是任意的1或0，但是最后一个Y是要取整的位置（相当于约等到这一位），那么这个数就是两个数的中位数，这个时候就要判断两个数那个是偶数。举例说明,$$10.00011_{2}(2\frac{3}{32})$$约等到$$10.00_{2}(2)$$, $$10.00110_{2}(2\frac{3}{16})$$约等到$$10.01_{2}(2\frac{1}{4})$$，因为这两个数都不符合上面的形式，在四分之一位（小数点后第二位）的后一位是1或者之后还有1，在这样的情况下就不用考虑向偶数对齐的问题了，可以直接约等到其最近的数；$$10.11100_{2}(2\frac{7}{8})$$约等于$$11.00_{2}(3)$$，$$10.10100_{2}(2\frac{5}{8})$$约等于$$10.10_{2}(2\frac{1}{2})$$，这两个数都是符合上述形式的，所以在取整的时候要取到一个偶数，方法就是把Y中最后一个0置1，其后的所有位置都置0。

##浮点数的比较

因为浮点数在表示的时候是经过取整（Rounding）的，所以在进行运算的时候不是一个精确的过程，在判断相等的时候就有问题要考虑了。

###常规方法

常用的方法是处理整数时用的“==”符号，它用来判断符号两端的两个整数是否相同。但是由于在浮点数在表示的时候本身就是取整后有误差的值，在进行运算的时候这个误差会再进行变化，如果仅仅以==来判断是不准确的，因为两个值本身就是不准确的。

###改进方法

常用的是用绝对误差e来衡量两个浮点数的相对关系，但是存在问题，两个浮点数的精度不同，所以差值的精度也不同，用一个相对固定的绝对差来衡量显然是不对的。

既然绝对误差过于“绝对”了，那可以试试相对误差。相对误差就是用两个浮点数的差值比上其中一个浮点数，以百分比的形式表示两数的差别。但是，会出现很多小问题，比如两个数都为0的情况下，会出现百分比是一个NaN的情况，这种情况下会判断两个数不同。另外，在处理比较小的数，即数值接近0的数的时候，这种百分比的形式会比较无力，因为做分母的数本来就很小。但是这个百分比的相对判断方式已经比绝对差的方式进步很多了，至少灵活度上提升了，有一般性的趋势。

###反璞归真

浮点数在计算机中的表示方法都清楚了，那能不能从它的表示方法入手判断呢？首先看到，一个浮点数的表示石油S，E，M三部分组成的，然后先抛开符号位S不说，单看E，可以发现从0到infinity，E的绝对大小是在递增的，而且和所表示的值的绝对值是正相关的，同时，在E相同的情况下，M部分也有类似的属性。所以，**整个浮点数的值V的相对关系，和其对应的二进制数的相对关系相对应**。

这样在判断浮点数的时候可以将其转化成整数然后进行比较，即可得到相对关系

	if (*(int*)&f1 > *(int*)&f2) {}

针对负数的情况，当两数符号不相同，那比较很显而易见。在符号相同的时候，即两者都是负数的情况，在比较的时候就相当于比较其除了符号位之外的数值，然后对结果取反。

或者用0x80000000去减那个负数，得到的负数间进行比较大小关系就和原浮点数的大小关系是一致的了，另外，这样处理之后，可以把0附近的小数转化为-1即以下的负数，可以和正数连接起来，使得最小的正数和最大的负数是相邻的。

在判断两个浮点数能不能相等的时候，也可以借助对应整数的差值来判断，因为当两个浮点数相邻的话，那么它们对应的二进制表示对应的值也是相邻的，这个可以很直观的得到。而为了承受在运算中可能丢失的精度，所以不可能直接根据这两个值进行比较，要允许两个值之前有一定的差别，这个相当于之前提到的绝对差值e，但是这个是在M中的变化，即，通过E的变化之后，这个e产生的实际差距是会比现在有所不同。所以，有些类似相对差值里思想。

另外，为了避免infinity值或者NaN对判断产生的影响，要限制差值的大小，让其不能达到可以影响到E的程度，所以限制在$$2^{22}$$以下。

所以可以得到下面的检测代码：

	bool AlmostEqual2sComplement(float A, float B, int maxUlps)
	{
		// Make sure maxUlps is non-negative and small enough that the
		// default NAN won't compare as equal to anything.
		assert(maxUlps > 0 && maxUlps < 4 * 1024 * 1024);
		
		int aInt = *(int*)&A;
		// Make aInt lexicographically ordered as a twos-complement int
		if (aInt < 0)
			aInt = 0x80000000 - aInt;
    
		// Make bInt lexicographically ordered as a twos-complement int
		int bInt = *(int*)&B;
		if (bInt < 0)
			bInt = 0x80000000 - bInt;
		
		int intDiff = abs(aInt - bInt);
		if (intDiff <= maxUlps)
			return true;
		return false;
	}

##总结

1. 所有上面的叙述都是建立在float-point分配了32bit空间的基础上，如果某个架构中float-point的空间有不同，那需要对上述中的常量进行一些改进，但是整体的思想是不会变的；

2. 计算机体系里处理离散的数据是比较“自然”的，但是在处理连续的数据的时候一般都会设计到精度的问题；

3. 在二进制的存储体系下，数据都是要以二进制的形式存在，所以如果能从更为直接的角度来分析，可能问题能简化。

##参考文献

1. CSAPP 2.4
2. [Comparing floating point numbers](http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm)
